主题：	
	1.arm指令集的说明(大小写不敏感)
	2.ARM-Thumb过程调用标准(ATPCS，规定了函数如何调用)
	3.用Makefile管理程序的编译
	4.数据处理指令(mov/mvn)
	5.算术指令(add/sub)
	6.比较指令(cmp)
	7.分支指令(b/bl)
	8.单寄存器load-store指令(ldr/str/ldrh/ldrb)
	9.软件中断指令(swi/svc)


作业：
1. 结合ldr/str/cmp/b/bl等指令
在c代码中准备并打印数组，在asm代码中排序

2. 登录开发板，在/data目录下创建文件mytest.txt，随意写一些内容；
用swi指令实现open以及read，打印文件内容；
我的例子封装的是write，大家试试open/read/close



1. arm指令集的说明
==========================
(1)ARM指令集的版本
--------------------
ARM采用精简指令架构(RISC)，其指令集目前已经发展到v8，苹果iphone6/6s/7的64位A8/A9/A10处理器采用的就是v8指令集;
EXYNOS4412处理器采用v7指令集;
s5p6818处理器采用v8指令集；

从软件兼容性方面考虑，新的指令集一般主要增加一些DSP、多媒体处理等方面的功能，很少会修改或废弃旧的指令；
但是ARM并不像INTEL一样严格保证向后兼容，这会导致一些老的程序不能在新的处理器上运行；


(2)arm指令的基本语法
---------------------
ARM指令通常带有2个或3个操作数，例如加法指令的语法为：
  add Rd, Rn, Rm
r3: 目标寄存器(Rd)
r1: 源寄存器1(Rn)
r2: 源寄存器2(Rm)

例子：
  add r3, r1, r2
//把存放在寄存器r1和r2中的值相加，然后把结果放到r3中

我们只需要学习最常用的一些汇编指令；
详细的指令信息可以参考ARMv7的架构手册(手册A8部分的A8.8章节)；


(3)指令的长度和书写方法
-----------------------
对CortexA9内核来说，ARM指令编码后每条32位；为了节省内存空间，也可以编码为16位的thumb指令

书写ARM汇编指令时，可不区分大小写，但建议格式统一，要么统一用大写，要么统一用小写；

例如下面的写法都可以：
MOV	R0, R1
mov r0, r1
Mov r0, R1 @不推荐混合使用大小写


(4)注释方法
---------------------
如果是使用arm公司提供的汇编器，则分号";"后面的内容为注释；

如果使用arm-linux-as，则将"@"后面的内容视为注释；
在arm-linux-as中，还可以用/* ... */来注释，但不能用//注释；



2. ARM-Thumb过程调用标准(ATPCS)
===============================
(1)说明
----------------------
当一个项目中既包括用汇编语言写的源文件，也包括用C语言写的源文件时，就必然要涉及到汇编代码和C函数之间的调用问题；
此时需要定义一套规范，以指明函数调用时如何传递参数，如何传递返回值等；

针对这一要求，ARM提出了一套标准，称为ARM-Thumb过程调用标准(ATPCS)，其中规定了如何通过寄存器来传递函数的参数和返回值；

ATPCS标准中最主要的规则如下：
--> 一个函数中最前面的四个参数通过ARM的前4个寄存器r0,r1,r2和r3传递
--> 从第5个参数开始，以后的参数通过递减满堆栈传递
--> 函数返回的变量通过寄存器r0传递

传递图：
...
sp+16	参数8
sp+12	参数7
sp+8	参数6
sp+4	参数5
sp	参数4
r3	参数3
r2	参数2
r1	参数1
r0	参数0	返回值

r0-r3: 	用来存放函数的前4个参数，r0还用于保存函数的返回值
r4-r12: 可以用来分配局部变量，但使用前要通过堆栈保存
r13: 栈指针
r14: 函数调用时保存返回地址
r15: pc

函数调用的优化原则：
尽量限制一个函数的参数，不要超过4个

汇编调用C代码和C调用汇编代码的例子:
汇编调用C函数：
	test1.c

	int func_a(int a, int b, int c)
	{
		return (a+b+c);
	}

	test2.s
	mov r0, #10
	mov r1, #20
	mov r2, #30
	bl func_a
	cmp r0, #60
	beq equal
	bne not_equal

equal:
	...
not_equal:
	...


C调用汇编的函数:
	test3.s
	/* 在汇编中定义func_b(int a, int b, int c)函数，返回(a-b-c) */
.global func_b
func_b:	
	sub r3, r0, r1
	sub r3, r3, r2
	mov r0, r3
	mov pc, lr

	test4.c
	int ret;
	ret = func_b(10, 20, 30);
	if (ret < 0) 
		...;
	else 
		...;



3. 用Makefile管理程序的编译
==========================
如果需要编译多个.s或.c文件，最好通过Makefile对文件的编译、安装、删除等进行管理。

最简单的makefile如下：
$>vim Makefile
all: hello.c
	arm-linux-gcc -o abc hello.c
clean:
	rm -f abc

$>make all
$>make clean

(1)基本格式
-------------------------
目标(target) : 依赖(depedence)
<tab>命令(command)

(2)通用的Makefile
-------------------------
$>vim Makefile
src := $(shell ls *.c)
obj := $(patsubst %.c, %.o, $(src))
elf := test

$(elf): $(obj)
	arm-linux-ld -o $@ $^
%.o: %.c
	arm-linux-gcc -c -o $@ $<
clean:
	rm -f $(elf) $(obj)

上面的$@,$^以及$<为自动变量。
$@表示规则的目标文件名；
$^表示所有依赖的名字，名字之间用空格隔开；
$<表示第一个依赖的文件名
%为通配符，和一个字符串中任意个数的字符相匹配


(3)Makefile的例子
--------------------
如果当前要编译一个c文件mov.c和一个汇编文件mov_asm.s，Makefile的内容如下：
TARGET	:= mymov
SRC_A	:= $(shell ls *.s)
SRC_C	:= $(shell ls *.c)
OBJ_A	:= $(patsubst %.s, %.o, $(SRC_A))
OBJ_C	:= $(patsubst %.c, %.o, $(SRC_C))

CROSS	:= arm-linux-
CC		:= $(CROSS)gcc
AS		:= $(CROSS)as
CFLAGS  += -Wall

all: $(OBJ_A) $(OBJ_C)
	$(CC) $(CFLAGS) $^ -o $(TARGET)
	cp $(TARGET) /srv/ftp/class-e6818/test/

%.o:%.s
	$(AS) $< -o $@
%.o:%.c
	$(CC) -c $< -o $@

clean:
	rm -f $(OBJ_A) $(OBJ_C) $(TARGET) 

测试：
$>make  //生成elf格式的程序mymov
$>make clean




4. 数据处理指令
========================
(1)mov/mvn
----------------------
最简单的arm指令，执行的结果就是把一个立即数N送到目标寄存器Rd，N可以是通用寄存器，也可以是常量。
语法：
  mov{<cond>}{S} Rd, N	
  mvn{<cond>}{S} Rd, ~N
mov: 把一个32位数存入寄存器Rd，即Rd = N
mvn: 把一个32位数按位取反后存入寄存器Rd
N为立即数，可以是一个寄存器Rn，也可以是一个使用"#"作为前缀的常量
指令可支持条件执行，可以附加S位

例1：
  mov r7, r5
  @执行前，r5=5, r7=8
  @执行后，r5=5, r7=5
例2：
  mov r7, #0x1f2  0001,1111,0010

(2)立即数可进行移位
-----------------------
立即数N可支持移位操作；
例子：
  mov r7, r5, lsl #2
  @执行前，r5=5, r7=8
  @执行后，r5=5, r7=20

常用的移位类型:
lsl 逻辑左移 x<<y
lsr 逻辑右移 (unsigned)x>>y
asr 算术右移 (signed)x>>y

注意！立即数N的有效位数是受到限制的，有效位数为8位(比如,0x1ff的有效位数为9位，0x8100有效位数为8位)，可进行31位的位移

例子见mov/，测试一下lsr和asr等移位方式



5. 算术指令
==================================
用于实现32位有符号数或无符号数的加法和减法
语法：
  add{<cond>}{S} Rd, Rn, N
  sub{<cond>}{S} Rd, Rn, N
add: 32位加法, Rd=Rn+N
sub: 32位减法, Rd=Rn-N

例1:
  add r0, r1, r1, lsl #1
  @执行前，r0=0x0, r1=0x5
  @执行后，r0=0xF, r1=0x5

例2:	
  sub r0, r1, r2
  @执行前，r0=0x0, r1=0x2, r2=0x1
  @执行后，r0=0x01

例3: 执行指令后影响CPSR	
  mov  r1, #1
  subs r0, r1, #1
  @执行前，cpsr=nzcv, r1=0x1
  @执行后，cpsr=nZcv, r0=0x0

例子见arith/
课后在例子中增加对乘法和除法的测试;



6. 比较指令
=============================
比较指令用于对一个寄存器中的值和一个立即数进行比较或测试。比较指令根据结果更新cpsr的标志位，但不影响其它的寄存器。
当比较指令改变了标志位后，后续指令就可以通过条件执行来改变程序的执行流程。比较指令不使用S后缀就可以改变标志位。

语法：
  cmp{<cond>} Rn, N
cmp：比较(根据Rn-N设置标记位)

例1：
  cmp r0, r9
  @执行前，cpsr标志为nzcv
  @r0 = 4, r9 = 4
  @执行后cpsr标志为nZCv, r0/r9不变

例子见compare/



7. 分支指令(branch)
==========================
分支指令可以改变程序的执行流程或者调用子程序;
这种指令使得程序可以实现子程序调用，if-else结构以及循环等;
执行流程的改变会迫使程序计数器pc指向一个新的地址;

语法：
  b{<cond>}  label
  bl{<cond>} label
b:  跳转, pc=label
bl: 带返回的跳转, pc=label, lr=bl指令后面一条指令的地址

b指令一般用于实现c代码中的if-else分支，或者for/while循环；
bl指令一般用于实现函数调用/返回;

例1:直接跳转
myadd:
  add r0, r1, r2
  ...
  b	myadd
  ...
标号放在一行的开始处，后面加冒号；
标号的命名类似于c语言中的函数或变量，只能用字母或_开头，后面可以加数字；


例2:带链接的跳转
@函数定义
myfunc:
  ...
  mov    pc, lr	@返回

  @r0等于0时调用函数
  cmp    r0, #0
  bleq   myfunc 
  ...
_myfunc: 


例3：基于局部标号的跳转
1:
  ...
1:
  ...
  b 1f @backward/forward
  ...
1:
  ...
在一个.s文件中，字母开头的标号视为全局标号，是不能重名的；
而纯数字的标号认为是局部标号，可以重名；

例子见acc/



8. 单寄存器load-store指令
============================
load-store指令用于在内存和通用寄存器之间交换数据;
ARM是不能直接操作内存中的数据的，必须首先把数据用load指令从内存读取到通用寄存器中，然后才能进行计算，最后再用store指令将运算的结果写回内存；

(1)指令说明
------------------------
语法：
  ldr{<cond>} Rd, address
  str{<cond>} Rd, address
ldr: 把一个word(32位)从内存读入通用寄存器Rd
str: 把一个通用寄存器的内容(32位)写入内存

如果需要读写16位数据(半字half-word)，可以用ldrh/strh；
如果需要读写8位数据(byte)，可以用ldrb/strb；

address是内存中的地址，可以直接写一个标号；
也可以先把基地址存到寄存器中，然后采用[基地址+/-偏移量]的方式访问内存；

偏移量也可以有多种表示。可以直接用常数作为偏移量，也可以用另一个寄存器做偏移量。
如：
  [Rn, #+/-offset_12]
  [Rn, +/-Rm]
  [Rn, +/-Rm, shift_imm]

ldr和str最好装载和存储地址对齐的数据;
如ldr只能从0,4,8等地址装载32位的word;

	mov 	r1, #0x8000	//0x8000为基地址
	ldr 	r0, [r1] //从0x8000读4个字节到r0
	ldrh 	r0, [r1] //从0x8000开始读2个字节到r0
	ldrb 	r0, [r1] //从0x8000开始读1个字节到r0
	ldr 	r0, abc
abc:
	.word 0x12345678

相当于C语言中的：
	int abc = 0x12345678;


(2)基于[]寻址
-------------------------------
arm为ldr/str指令设计了几种不同的寻址方式；

例1: 基地址
  mov r1, #0x8000
  ldr r0, [r1]
  @从地址单元0x8000读4个字节，存入r0
  @r1的内容不变

例2：基地址加偏移
  mov r1, #0x8000
  ldr r0, [r1, #8]
  mov r2, #0x100
  ldr r3, [r1, r2]
  @从地址单元0x8008读4个字节，存入r0
  @从地址单元0x8100读4个字节，存入r3
  @r1的内容不变

例3：访问单元采用基地址加偏移；更新基地址
  mov r1, #0x8000
  ldr r0, [r1, #8]!
  ldr r2, [r1, #4]
  @从地址单元0x8008读4个字节，存入r0
  @r1的内容变为0x8008
  @从地址单元0x800C读4个字节，存入r2

例4：只更新基地址
  mov r1, #0x8000
  ldr r0, [r1], #8
  ldr r2, [r1]
  @从地址单元0x8000读4个字节，存入r0
  @r1的内容变为0x8008
  @从地址单元0x8008读4个字节，存入r2


(3)基于标号寻址
---------------------------
在汇编中，标号实际上也是地址，因此可以直接在ldr/str指令后面使用标号；

例1：
@相当于C中的：int abc=0x12345678
 ...
  ldr r0, abc
abc:
  .word 0x12345678
 
例子见load/，自行测试一下str指令



9. 软件中断指令
=======================
(1)软件中断
---------------------
中断是由硬件产生的异常，而软件中断是通过执行特定的指令产生的异常；

ARM定义了指令swi(ARMv7后更名为svc)来产生一个软件中断异常；
当处理器执行完svc指令后，不会继续执行svc后面的指令，而是首先将CPU切换到SVC模式，然后将pc设定为异常向量表基地址+0x8，并从此处继续执行；

swi/svc指令的最主要工作就是将cpu从非特权的usr模式(对应linux的用户态)提升到特权的SVC模式(对应Linux的内核态);

大家在linux用户态编程时学到的open/read等系统调用，在arm平台上就是通过swi指令实现的；
通常在用户模式下调用swi，从而使处理器从非特权模式(usr)切换到特权模式(svc)。

linux的内核的系统调用号可参考头文件arch/arm/include/asm/unistd.h


(2)swi/svc指令
----------------------
语法：
  svc{<cond>} number
指令后面的数字为系统调用号，最大为0xffffff;
系统调用号直接编译到指令代码中(参ARMv7手册)

执行svi指令后，处理器的执行步骤如下：
--> 在lr_svc寄存器中记录swi指令后面一条指令的地址;
--> 将cpsr的值(执行swi指令时所处的处理器状态)存入spsr_svc
--> pc = 异常向量表基地址 + 0x8
--> 将cpu切换到SVC模式
--> cpsr_I = 1(屏蔽IRQ中断)

例1：执行编号为0x900123的系统调用
  svc 0x900123

参考svc/



