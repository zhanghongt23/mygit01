主题
	1. ARM处理器的简介
	2. ARM的处理器模式(usr/svc/irq/abt/unf)
	3. ARM的通用寄存器(r0~r12,sp,lr,pc)
	4. 当前程序状态寄存器(CPSR/SPSR)
	5. ARM指令的条件标志和条件执行
	6. 异常向量表(0x0/0xffff0000)


1. ARM处理器的简介
=======================
ARM即Advanced RISC Machine的缩写，是一家英国的芯片设计公司;
2016年被日本软银收购；

ARM的历史并不算长，但取得的成绩是惊人的，关于ARM处理器的发展历史，可以参考datasheet/arm-history.pdf

完整的ARM信息参考官方网站：www.arm.com

不同的arm可能有不同版本的指令集，CortexA9采用v7指令集，CortexA53/A7x(64位)采用v8指令集

ARM微架构(指令集)：
ARM7(v4)-->ARM9(v4T/v5) -->ARM11(v6)
CortexA8(v7)-->CortexA9/A15(v7)
CortexA5x/A7x(v8,64bit)

arm的相关手册可以参考datasheet/下面的pdf文档




2. ARM的处理器模式
============================
arm处理器在运行过程中可以在不同的处理模式间切换，但任一时刻只能处在一种模式下；
在ARM11之前，ARM处理器一共有7种模式，从ARM11以后开始增加了第8个模式(Secure Mode)。我们的课程只涉及前7种模式。

这7种模式分为两类，特权模式(6种)和非特权模式(1种)
具体的模式如下：
(1)Usr用户模式(非特权)
(2)FIQ快速中断模式
(3)IRQ中断模式
(4)SVC管理模式(Supervisor)
(5)SYS系统模式
(6)Abt中止模式(Abort数据异常)
(7)Und未定义模式(Undefined指令异常)
处理器在运行代码时，会根据情况在上述模式间不停切换
对于linux来说，只用到了上面的usr,irq,svc,abt,und等5个状态



3. ARM的通用寄存器
=========================
在每种处理器模式下，都可以访问ARM核心中的通用寄存器；
我们编写供处理器使用的汇编代码时，要利用这些通用寄存器进行计算、比较等；还可以将内存中的数据载入(load)到通用寄存器中，或者将通用寄存器的内容存储(store)到内存单元中。

arm要执行运算或者比较等操作，必须先把数据读入通用寄存器，才可以进行运算;


(1)每种模式下均可访问的通用寄存器
---------------------------
在任何一个状态下，都可以访问到下面的通用寄存器：
r0
r1
r2
r3
r4
r5
r6
r7
r8
r9
r10
r11
r12
r13(sp)
r14(lr)
r15(pc)
cpsr
(spsr)

r13：常用作栈指针(sp)，保存当前处理器模式的堆栈的栈地址
r14：链接返回寄存器(lr)，在调用子程序时保存返回地址
r15：程序计数器(pc)，处理器要取的下一条指令的地址
cpsr：通用状态寄存器
spsr：备份状态寄存器(当中断或异常发生时保存cpsr，用户模式下没有SPSR)

可以参考datasheet/01arm1176/arm架构手册的P43图2-1
上面的寄存器中，r0~r15是通用寄存器，可用来存储任意值；
cpsr/spsr是状态寄存器，用于获取ARM当前状态以及模式控制(见后文)

ARM一共有37个寄存器(大家自己算算，看对不对？)




4. 当前程序状态寄存器(CPSR)
==============================
CPSR是一个专用的32位状态和控制寄存器，ARM核中只有一个，在任何模式下都可以访问；
只有当CPU核处于特权模式时才可以修改CPSR的值，非特权模式下只能读CPSR的值；

(1)CPSR的核心位定义
-------------------------
CPSR的具体位在ARM核的不同微架构中有不同的含义，最核心且一直没有改变的位如下：
bit31(N): 负数(Negative)标志
bit30(Z): 零(Zero)标志
bit29(C): 进位(Carry)标志
bit28(V): 溢出(oVerflow)标志
bit7(I): 中断(Interrupt)屏蔽(mask)
bit6(F): 快速(Fast)中断屏蔽(mask)
bit5(T): 决定当前执行ARM指令(32bit)还是Thumb指令(16bit)
bit[4-0](Mode): 处理器的模式

其中，最高的4位是状态位，记录上一条指令的执行结果，程序不用直接修改；而最低8位为控制位，可以通过软件写入不同的值，从而切换处理器状态，屏蔽中断等。只有特权模式才可以写控制位，用户模式只能读。

Mode的值和处理器模式的对照如下：
Mode     含义
10000 	Usr用户模式(非特权)
10001 	FIQ快速中断模式
10010 	IRQ中断模式
10011 	SVC管理模式
11111 	SYS系统模式
10111 	Abt中止模式
11011 	Und未定义模式


(2)中断屏蔽(mask)
------------------------
CPSR的F和I位可用于中断的屏蔽，也就是暂时阻塞中断，以防止中断请求打断当前代码的执行。屏蔽的时间要尽量短，一旦打开屏蔽，则处理器要马上处理屏蔽期间可能产生的中断。

ARM核有两个级别的中断请求-->中断请求IRQ和快速中断请求FIQ
I位设为1时，屏蔽IRQ；I位为0时，IRQ打开
F位设为1时，屏蔽FIQ；F位为0时，FIQ打开



5. ARM指令的条件标志和条件执行
===============================
(1)条件标志
------------------------
即CPSR状态寄存器的N,Z,C,V位。arm在执行比较指令或带有后缀S的算数指令后，会将执行结果存储在这几个位中。

例1：带有s后缀的指令
  mov 	r1, #1
  subs 	r1, r1, #1
上面指令的含义为"r1=r1-1"，由于计算结果出现了0，并且减法指令sub带有s后缀，所以指令执行完后会设定cpsr的z位为1

例2：比较指令
  mov 	r1, #4
  mov 	r2, #4
  cmp 	r1, r2
cmp是比较指令，用于判断两个寄存器中的值是否相等。其实质是将r1和r2中的内容相减。由于r1和r2中的值相等，所以上面的指令执行完后会设定CPSR寄存器的z位为1


(2)条件执行
----------------------
用于控制ARM核是否应执行本条指令；
例如一条普通的跳转指令为B，系统执行到这条指令时会无条件执行下去，而如果为这条指令附加条件助记符，如BEQ(含义是前面一条指令的结果为相等时才执行本指令)，则系统会首先根据CPSR中的条件标志位进行判断，满足条件后才执行BEQ指令。

	if (a == b) {
		...;
	}
	else {
		....;
	}

例：用汇编语言实现if--else
	...
	cmp r1, r2
	bleq test
	bleq xxx
	blne ccc
	mov r0, #3
	bleq aaa
	mov 
	movshi

	blne bbb
	blne xxx
	movne ...
	addne ...


(3)ARM支持的全部条件助记符
---------------------------
可以在标准的ARM指令后面附加条件助记符，这样该指令就成为条件执行的指令了；
(以下的条件标志用大写字母表示1，小写字母表示0)
助记符	名称			条件标志
EQ(==)	等于	        	Z(比较)
NE(!=)	不等于 	        	z(比较)

GE(>=)	有符号数大于或等于	NV或nv
GT(>)	有符号数大于		NzV或nzv
LE(<=)	有符号数小于或等于	Z或Nv或nV
LT(<)	有符号数小于		Nv或nV

CS(>=)	无符号数大于或等于	C
HI(>)	无符号数大于		zC
LS(<=)	无符号数小于或等于	Z或c
CC(<)	无符号数小于		c

MI	负数			N
PL	非负数			n
VS	溢出			V
VC	无溢出			v

AL	无条件执行		忽略

任何一条ARM指令都可以增加条件执行标志，如果没有，则默认采用AL。




6. 异常向量表(Exception Vector Table)
==========================
当一个异常发生时，ARM处理器会把PC设置到一个特定的地址位置，然后从这些地址中加载指令执行；
这一特定的地址范围称为异常向量表(vector-table)；

异常向量表是由软件开发人员准备的，软件人员要负责在向量表中放置一系列跳转指令，跳转到专门处理某个异常的子程序(这些子程序也由软件人员负责准备)；

异常向量表可以放置在低地址0x0000,0000处，或者高地址0xffff,0000处；

当ARM处理器复位时，处理器采用物理地址，此时从地址0x0处查找异常向量表；
当程序准备好页表并使能mmu后，处理器将采用虚拟地址，此时应当到地址0xffff,0000处查找异常向量表；

当一个异常或中断发生时，处理器会挂起正常的操作，转而从向量表的对应位置装载指令执行。


(1)异常向量表的位置分布
-----------------------------
异常/中断		地址
复位			0x0
未定义指令     	0x4或0xffff,0004
软件中断(SVC)   0x8或0xffff,0008
取指令异常		0xc或0xffff,000c
取数据异常		0x10或0xffff,0010
保留	   		0x14或0xffff,0014
中断IRQ			0x18或0xffff,0018
快速中断FIQ		0x1c或0xffff,001c

异常向量表的基地址(虚拟地址为0xffff,0000，物理地址为0x0)
一旦硬件产生中断，pc跳转到0xffff,0018
三星将iROM放到物理地址的0x0开始的64KB


(2)说明
-----------------------
复位(RESET):
处理器上电后执行的第一条指令的位置。这条指令将跳转到初始化代码

未定义指令(UNDEF):
处理器无法对一条指令译码时会产生异常，跳转到这里

软件中断(SWI):
处理器执行一条SWI指令后跳转到此处，此时，ARM核从非特权的USR模式切换到特权的SVC模式；
Linux从用户态到内核态的切换就是通过SWI指令实现的。用户应用程序使用的系统调用(如open,read,write)就是通过软件中断切换到内核中

预取指中止(PART):
处理器试图从一个未获得正确访问权限的地址取指令时发生

预取数据中止(DART):
处理器试图从一个未获得正确访问权限的地址取数据时发生

中断请求(IRQ):
当外设给处理器发来一个中断请求后，会跳转到此处

快速中断请求(FIQ):
外设可以将自己产生的中断设置为FIQ，比IRQ优先级高



